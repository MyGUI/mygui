/* Original version Copyright (C) Scott Bilas, 2000.
 * All rights reserved worldwide.
 *
 * This software is provided "as is" without express or implied
 * warranties. You may freely copy and compile this source into
 * applications you distribute provided that the copyright text
 * below is included in the resulting source code, for example:
 * "Portions Copyright (C) Scott Bilas, 2000"
 */
#ifndef __INSTANCE_H__
#define __INSTANCE_H__

// Added by Steve Streeting for Ogre
//#include "OgrePrerequisites.h"
#include "assert.h"

#if defined( _MSC_VER )
// Turn off warnings generated by this singleton implementation
#   pragma warning (disable : 4311)
#   pragma warning (disable : 4312)
#endif

//#if defined ( OGRE_GCC_VISIBILITY )
//#   pragma GCC visibility push(default)
//#endif
namespace MyGUI {
// End SJS additions
    /** Template class for creating single-instance global classes.
    */
    template <typename T> class Instance
    {
    protected:

        static T* msInstance;

    public:
        Instance( void )
        {
            assert( !msInstance );
#if defined( _MSC_VER ) && _MSC_VER < 1200	 
            int offset = (int)(T*)1 - (int)(Instance <T>*)(T*)1;
            msInstance = (T*)((int)this + offset);
#else
	    msInstance = static_cast< T* >( this );
#endif
        }
        ~Instance( void )
            {  assert( msInstance );  msInstance = 0;  }
        static T& getInstance( void )
		{	assert( msInstance );  return ( *msInstance ); }
        static T* getInstancePtr( void )
		{ return msInstance; }
    };
}

		/** Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.
        */

		/** Override standard Singleton retrieval.
        @remarks
        Why do we do this? Well, it's because the Singleton
        implementation is in a .h file, which means it gets compiled
        into anybody who includes it. This is needed for the
        Singleton template to work, but we actually only want it
        compiled into the implementation of the class based on the
        Singleton, not all of them. If we don't change this, we get
        link errors when trying to use the Singleton-based class from
        an outside dll.
        @par
        This method just delegates to the template version anyway,
        but the implementation stays in this single compilation unit,
        preventing link errors.
        */

#define INSTANCE_HEADER(type) \
	public: \
	static type& getInstance(void); \
	static type* getInstancePtr(void);

#define INSTANCE_IMPLEMENT(type) \
	template<> type* Instance<type>::msInstance = 0; \
	type* type::getInstancePtr(void) {return msInstance;} \
	type& type::getInstance(void) {if (!msInstance)msInstance=new type();return (*msInstance);}

//#if defined ( OGRE_GCC_VISIBILITY )
//#   pragma GCC visibility pop
//#endif
#endif // __INSTANCE_H__
